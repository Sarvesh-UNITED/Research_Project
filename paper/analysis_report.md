# Analysis Report: Alignment of Codebase with Research Paper

## Executive Summary
The codebase (`aas-sim`) has been analyzed and compared against the research paper "A Simulation-Based AAS Architecture for Usage-Based Operation and Billing of Modular Devices". 

**Conclusion:** The codebase **strongly reflects** the architecture, logic, and scenarios described in the research paper. The implementation of the `SubUsageBilling` submodel, the billing formulas for AGV and Engraver, and the simulation orchestration are consistent with the paper's specifications.

## Detailed Analysis

### 1. Architecture Alignment
*   **Paper Specification:** Describes a three-tier architecture with a Next.js frontend, FastAPI backend (Orchestrator), and AAS-compliant device models.
*   **Codebase Reality:** The project structure perfectly matches this specification:
    *   `frontend/`: Next.js application.
    *   `backend/app/main.py` & `orchestrator.py`: FastAPI application and Orchestrator logic.
    *   `backend/app/models.py`: Pydantic models implementing the AAS structure.

### 2. AAS Submodel Implementation
*   **Paper Specification:** Defines a `SubUsageBilling` submodel with specific attributes:
    *   **AGV:** `distanceTraveled`, `costPerMeter`, `usageCost`, `orderRef`.
    *   **Engraver:** `energyConsumed`, `emissionFactor`, `carbonEmissions`, `costPerEnergyUnit`, `usageCost`.
*   **Codebase Reality:** The `models.py` file defines `AGVBillingModel` and `EngraverBillingModel` with **exact matches** for all these fields. The JSON structure generated by the API aligns with the paper's examples.

### 3. Billing Logic & Formulas
*   **Paper Specification:**
    *   **AGV:** `Cost = Distance * Rate`. Selective billing (excluding Home->Dock).
    *   **Engraver:** `Energy = BaseIdle + (k_laser * Time)`. `Cost = Energy * Rate`. `CO2 = Energy * EmissionFactor`.
*   **Codebase Reality:** The `orchestrator.py` implements these formulas precisely:
    *   `_agv_add_distance_if_billed` logic ensures only specific legs are billed.
    *   `run_engrave_job` calculates energy using the base + laser formula and derives CO2 and Cost exactly as specified.

### 4. Scenarios
*   **Paper Specification:**
    *   **Scenario 1 (Batch):** Jobs "HELLO", "WORLD", "TEST" at `JOB_POS1`.
    *   **Scenario 2 (Individual):** Job "SMART" at `JOB_POS1`, "FACTORY" at `JOB_POS2`.
*   **Codebase Reality:** `backend/app/core/rules.py` defines `SCENARIO_1_JOBS` and `SCENARIO_2_JOBS` with the **exact same data** (Order IDs, Text, Sites) as described in the paper.

### 5. Discrepancies & Observations
While the logic and structure are aligned, there are minor differences in default configuration values between the paper's text/tables and the code's default config:

| Parameter | Paper (Table 4.2) | Paper (Evaluation Text) | Code (`config.yaml` / defaults) |
| :--- | :--- | :--- | :--- |
| **Emission Factor** | 360 gCO2/kWh | - | 420.0 gCO2/kWh |
| **AGV Cost/Meter** | €0.02 | €0.05 | €0.02 |

*   **Note:** The code uses `420.0` for the emission factor, whereas Table 4.2 in the paper cites `360`. The AGV cost is `0.02` in the code (matching Table 4.2) but the evaluation section of the paper mentions `0.05`. These are configuration differences and do not affect the validity of the architectural implementation.

### 6. Research Question
The paper addresses the gap in standardized billing for multi-stakeholder manufacturing. The implemented `SubUsageBilling` submodel directly answers the research objective by providing a technical solution for:
1.  **Fairness:** Usage-based vs Flat-rate (demonstrated by the simulation logic).
2.  **Sustainability:** Integrated Carbon Accounting (implemented in Engraver logic).
3.  **Interoperability:** AAS-compliant structure (implemented in Pydantic models).

## Final Verdict
The code is a faithful and complete implementation of the concepts, architecture, and validation scenarios presented in the research paper.
